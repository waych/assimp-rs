//! # assimp - Open Asset Import Library
//!
//! Bindings for the [Assimp](http://assimp.org/) library.

// #![warn(missing_docs)]

extern crate autogenerated_assimp_sys as ffi;

pub use import::{structs::PrimitiveType, FileIO, Importer};
pub use log::LogStream;
pub use math::{Color3D, Color4D, Matrix3x3, Matrix4x4, Quaternion, Vector2D, Vector3D};
pub use scene::{
    Animation, BlendOp, Camera, Face, Light, Mapping, Material, MaterialBlendOp, MaterialComponent,
    MaterialKey, MaterialValue, Mesh, Metadata, MetadataEntry, MetadataValue, Node, NodeAnim,
    QuatKey, Scene, Texture, TextureData, VectorKey,
};

use std::{cmp, fmt, ops};

#[macro_use]
mod internal_macros;

pub mod export;
pub mod import;
pub mod log;
pub mod math;
pub mod scene;

/// An "inline string", used in Assimp instead of heap-allocated cstrings. These are big - over 1000 bytes
/// large - and so where possible we return a string instead.
#[repr(transparent)]
pub struct InlineString(pub ffi::aiString);

impl Clone for InlineString {
    fn clone(&self) -> Self {
        InlineString(self.0)
    }
}

impl cmp::PartialEq for InlineString {
    fn eq(&self, other: &Self) -> bool {
        &**self == &**other
    }
}

impl fmt::Display for InlineString {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", &**self)
    }
}

impl fmt::Debug for InlineString {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", &**self)
    }
}

impl ops::Deref for InlineString {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        unsafe { aistring_to_cstr(&self.0).to_str().unwrap() }
    }
}

impl std::convert::AsRef<str> for InlineString {
    fn as_ref(&self) -> &str {
        &**self
    }
}

impl std::borrow::Borrow<str> for InlineString {
    fn borrow(&self) -> &str {
        &**self
    }
}

/// Error converting an `&str` to an `InlineString` - the string was more than
/// the supported length (1024 bytes).
pub struct StringTooLong;

impl std::convert::TryFrom<&str> for InlineString {
    type Error = StringTooLong;

    fn try_from(other: &str) -> Result<Self, Self::Error> {
        if other.len() >= 1024 {
            Err(StringTooLong)
        } else {
            Ok(InlineString(str_to_aistring(other)))
        }
    }
}

enum AiError {
    Failure,
    OOM,
}

fn aireturn_to_result(aireturn: ffi::aiReturn) -> Result<(), AiError> {
    if aireturn == 0 {
        Ok(())
    } else if aireturn == 2 {
        Err(AiError::OOM)
    } else {
        Err(AiError::Failure)
    }
}

unsafe fn aistring_to_cstr(aistring: &ffi::aiString) -> &std::ffi::CStr {
    std::ffi::CStr::from_bytes_with_nul_unchecked(std::mem::transmute(
        &aistring.data[..aistring.length as usize + 1],
    ))
}

fn str_to_aistring(val: &str) -> ffi::aiString {
    let bytes = val.as_bytes();

    assert!(bytes.len() < 1024);

    let mut data = [0u8; 1024];

    (&mut data[..bytes.len()]).copy_from_slice(bytes);

    let data = unsafe { std::mem::transmute(data) };

    ffi::aiString { length: bytes.len() as _, data }
}
